{"version":3,"sources":["apply.spec.js"],"names":["t","is","throws","f","TypeError","m","__data__","path","m1","__type__","map","p","m2","not","l1","list","l2","nestedMap"],"mappings":"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","file":"apply.spec.js","sourcesContent":["import test from 'ava'\n\nimport apply   from '../../source/immut/apply'\nimport symbols from '../../source/consts/symbols'\n\nimport {\n  _,\n} from '../../source/utils/curry.js'\n\nimport { testRefs } from '../helpers'\n\ntest('immut#apply: should be curryable', t => {\n  t.is(apply(_), apply)\n})\n\n\ntest('immut#apply: should error if data type is not an immut', t => {\n  t.throws(() => apply({}, [ 'p' ], f => f), TypeError)\n})\n\n\ntest('immut#apply: should error if immut does not contain key', t => {\n  const m = {\n    __data__: {},\n  }\n\n  t.throws(() => apply(m, [ 'p' ], f => f), TypeError)\n})\n\n\ntest('immut#apply: should apply f to map type', t => {\n  const path = [ 'p' ]\n  const m1 = {\n    __type__: symbols.map,\n    __data__: { p: 1 },\n  }\n\n  const m2 = apply(m1, path, f => f + 1)\n\n  t.not(testRefs(m1, m2, path))\n  t.is(m2.__data__.p, 2)\n})\n\n\ntest('immut#apply: should apply f to list type', t => {\n  const path = [ 1 ]\n  const l1 = {\n    __type__: symbols.list,\n    __data__: [ 1, 4 ],\n  }\n\n  const l2 = apply(l1, path, f => f + 1)\n\n  t.not(testRefs(l1, l2, path))\n  t.is(l2.__data__[1], 5)\n})\n\n\ntest('immut#apply: should apply f to nested map types', t => {\n  const path = [ 'nestedMap', 'p' ]\n  const m1 = {\n    __type__: symbols.map,\n    __data__: {\n      nestedMap: {\n        __type__: symbols.map,\n        __data__: { p: 21 },\n      }\n    },\n  }\n\n  const m2 = apply(m1, path, f => f + 10)\n\n  t.not(testRefs(m1, m2, path))\n  t.is(m2.__data__.nestedMap.__data__.p, 31)\n})\n\n\ntest('immut#apply: should apply f to nested list types', t => {\n  const path = [ 1, 3 ]\n  const l1 = {\n    __type__: symbols.list,\n    __data__: [\n      'zero',\n      {\n        __type__: symbols.list,\n        __data__: [ 0, 1, 2, 'three'],\n      },\n    ],\n  }\n\n  const l2 = apply(l1, path, f => f + ' pees in a pod')\n\n  t.not(testRefs(l1, l2, path))\n  t.is(l2.__data__[1].__data__[3],  'three pees in a pod')\n})\n\n\ntest('immut#apply: should apply f to nested immut types', t => {\n  const path = [ 1, 'p' ]\n  const m1 = {\n    __type__: symbols.list,\n    __data__: [\n      'zero',\n      {\n        __type__: symbols.map,\n        __data__: { p: -6 },\n      },\n      'two',\n    ],\n  }\n\n  const m2 = apply(m1, path, f => f + 7)\n\n  t.not(testRefs(m1, m2, path))\n  t.is(m2.__data__[1].__data__.p, 1)\n})\n"]}