{"version":3,"sources":["from.spec.js"],"names":["t","is","shape","type","keys","a","b","deepEqual","of","c","item","throws","TypeError","d1","d2","s","undefined"],"mappings":"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","file":"from.spec.js","sourcesContent":["import test from 'ava'\n\n\n//\n// NOTE: from is internally known as parse\n//\n\n\nimport parse from '../../source/immut/from'\n\nimport list from '../../source/list'\nimport map  from '../../source/map'\n\nimport {\n  ofMap,\n  ofList,\n  ofLeaf,\n} from '../../source/immut/from'\n\nimport { _ } from '../../source/utils/curry'\n\n\ntest('immut#from: should be curryable', t => {\n  t.is(parse(_), parse)\n})\n\n\ntest('immut#from: should parse simple map', t => {\n  const shape = {\n    type: map.type,\n    keys: {\n      a: '',\n      b: 33,\n    }\n  }\n\n  t.deepEqual(\n    parse(shape, { a: 'holla', b: 10 } ),\n    map.of({\n      a: 'holla',\n      b: 10,\n    })\n  )\n})\n\n\ntest('immut#from: should strip excess keys on map', t => {\n  const shape = {\n    type: map.type,\n    keys: {\n      b: 33,\n    }\n  }\n\n  t.deepEqual(\n    parse(shape, { a: 'holla', b: 33 }),\n    map.of({\n      b: 33,\n    })\n  )\n})\n\n\ntest('immut#from: should add defaults for missing keys', t => {\n  const shape = {\n    type: map.type,\n    keys: {\n      b: 33,\n      c: 'yolo',\n    }\n  }\n\n  t.deepEqual(\n    parse(shape, { b: 22 }),\n    map.of({\n      b: 22,\n      c: 'yolo',\n    })\n  )\n})\n\n\ntest('immut#from: should parse simple list', t => {\n  const shape = {\n    type: list.type,\n    item: 0\n  }\n\n  t.deepEqual(\n    parse(shape, [ 10, 22, 11 ]),\n    list.of([\n      10,\n      22,\n      11,\n    ])\n  )\n})\n\n\ntest('immut#from: should parse map of maps', t => {\n  const shape = {\n    type: map.type,\n    keys: {\n      b: 33,\n      c: {\n        type: map.type,\n        keys: {\n          a: \"kubernetes\",\n          b: \"docker\"\n        },\n      },\n    },\n  }\n\n  t.deepEqual(\n    parse(shape, { b: 1, c: { b: \"compose\" } }),\n    map.of({\n      b: 1,\n      c: map.of({\n        a: \"kubernetes\",\n        b: \"compose\",\n      }),\n    })\n  )\n})\n\n\ntest('immut#from: should parse list of lists', t => {\n  const shape = {\n    type: list.type,\n    item: {\n      type: list.type,\n      item: 0,\n    },\n  }\n\n  t.deepEqual(\n    parse(shape, [ [], [], [], [] ]),\n    list.of([\n      list.of(),\n      list.of(),\n      list.of(),\n      list.of(),\n    ])\n  )\n})\n\n\ntest('immut#from: should parse complex shape', t => {\n  const shape = {\n    type: list.type,\n    item: {\n      type: map.type,\n      keys: {\n        b: 33,\n        c: {\n          type: list.type,\n          item: 0,\n        },\n      },\n    },\n  }\n\n  t.deepEqual(\n    parse(shape, [ { b: 22 }, { c: [ 10, 11 ] }, {} ]),\n    list.of([\n      map.of({ b: 22, c: list.of() }),\n      map.of({ b: 33, c: list.of([ 10, 11 ]) }),\n      map.of({ b: 33, c: list.of() }),\n    ])\n  )\n})\n\n\ntest('ofMap: should throw if d !== {}', t => {\n  t.throws(() => ofMap(null, ''), TypeError)\n})\n\n\ntest('ofList: should throw if d !== []', t => {\n  t.throws(() => ofList(null, {}), TypeError)\n})\n\n\ntest('#ofList: should always return data if exists', t => {\n  const d1 = 'holla world'\n  const d2 = null\n\n  const s = 'holla space'\n\n  t.is(ofLeaf(s, d1), d1)\n  t.is(ofLeaf(s, d2), d2)\n  t.is(ofLeaf(s, undefined), s)\n})\n"]}