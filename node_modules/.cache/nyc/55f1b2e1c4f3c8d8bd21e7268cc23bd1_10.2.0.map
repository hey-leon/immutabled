{"version":3,"sources":["from.js"],"names":["parse","s","d","type","ofList","ofMap","ofLeaf","Object","of","entries","keys","reduce","acc","k","v","TypeError","Array","isArray","map","item","_d"],"mappings":";;;;;;;;;;AACA;AACA;AACA;;;AACA;;AACA;;AACA;;;;AACA;;;;;;;;AAYA;;;;;;;;;;AAUO,IAAMA,wBACX,SADWA,KACX,CAACC,CAAD,EAAIC,CAAJ;AAAA,SAAUD,KAAKA,EAAEE,IAAF,KAAW,eAAKA,IAArB,GAA4BC,OAAOH,CAAP,EAAUC,CAAV,CAA5B,GACAD,KAAKA,EAAEE,IAAF,KAAW,cAAIA,IAApB,GAA4BE,MAAMJ,CAAN,EAASC,CAAT,CAA5B,GACAI,OAAOL,CAAP,EAAUC,CAAV,CAFV;AAAA,CADK;;AAMA,IAAMG,wBACX,SADWA,KACX,CAACJ,CAAD;AAAA,MAAIC,CAAJ,uEAAM,EAAN;AAAA,SAAaA,MAAMK,OAAOL,CAAP,CAAN,GACT,cAAIM,EAAJ,CAAOD,OAAOE,OAAP,CAAeR,EAAES,IAAjB,EAAuBC,MAAvB,CAA8B,UAACC,GAAD;AAAA;AAAA,QAAOC,CAAP;AAAA,QAAUC,CAAV;;AAAA,wBAChCF,GADgC,sBAElCC,CAFkC,EAE9Bb,MAAMc,CAAN,EAASZ,EAAEW,CAAF,CAAT,CAF8B;AAAA,GAA9B,EAGH,EAHG,CAAP,CADS,GAKT,2BAAaE,SAAb,EAAwB,8BAAxB,CALJ;AAAA,CADK;;AASA,IAAMX,0BACX,SADWA,MACX,CAACH,CAAD;AAAA,MAAIC,CAAJ,uEAAM,EAAN;AAAA,SAAac,MAAMC,OAAN,CAAcf,CAAd,IACT,eAAKM,EAAL,CAAQN,EAAEgB,GAAF,CAAM;AAAA,WAAMlB,MAAMC,EAAEkB,IAAR,EAAcC,EAAd,CAAN;AAAA,GAAN,CAAR,CADS,GAET,2BAAaL,SAAb,EAAwB,8BAAxB,CAFJ;AAAA,CADK;;AAMA,IAAMT,0BACX,SADWA,MACX,CAACL,CAAD,EAAIC,CAAJ;AAAA,SAAUA,KAAKA,MAAM,IAAX,GACNA,CADM,GAEND,CAFJ;AAAA,CADK;;kBAMQ,kBAAMD,KAAN,C","file":"from.js","sourceRoot":"/Users/leon/Development/Javascript/immut/source/immut","sourcesContent":["// @flow\n//\n// NOTE: from is internally known as parse\n//\nimport { runtimeError } from '../utils/helpers'\nimport { curry }        from '../utils/curry'\nimport list             from '../list'\nimport map              from '../map'\nimport type {\n  Immut,\n  List,\n  Map,\n  Shape,\n  MapShape,\n  ListShape,\n  Leaf,\n} from '../consts/types'\n\n\n/**\n * takes a shape template and JSON like and parses\n * it to match the shape.\n *\n * @name immut.parse\n * @param {Object} s template of the shape\n * @param {Object} d to parse\n * @return {Immut|Leaf|void} the data parsed to match the shape\n * @since 0.0.1\n */\nexport const parse: (s: Shape | any, d: any) => Immut | Leaf | void =\n  (s, d) => s && s.type === list.type ? ofList(s, d)\n          : s && s.type === map.type  ? ofMap(s, d)\n          : ofLeaf(s, d)\n\n\nexport const ofMap: (s: MapShape, d: Object) => Map | void =\n  (s, d={}) => d === Object(d)\n    ? map.of(Object.entries(s.keys).reduce((acc, [k, v]) => ({\n        ...acc,\n        [k]: parse(v, d[k]),\n      }), {}))\n    : runtimeError(TypeError, 'Shape did not match the data')\n\n\nexport const ofList: (s: ListShape, d: any) => List | void =\n  (s, d=[]) => Array.isArray(d)\n    ? list.of(d.map(_d => parse(s.item, _d)))\n    : runtimeError(TypeError, 'Shape did not match the data')\n\n\nexport const ofLeaf: (s: any, d: any) => Leaf | void =\n  (s, d) => d || d === null\n    ? d\n    : s\n\n\nexport default curry(parse)\n"]}